const express = require('express');
const router = express.Router();
const { supabase } = require('../config/database');
const { verifyCounselorSession } = require('../middleware/sessionManager');
const aiService = require('../utils/aiService');

// POST /api/ai-interventions/generate - Generate AI intervention for a student
router.post('/generate', verifyCounselorSession, async (req, res) => {
  try {
    const counselorId = req.user.id;
    const { studentId, assessmentId } = req.body;
    
    console.log('Generating AI intervention for student:', studentId);
    
    // Validate required fields
    if (!studentId) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: studentId'
      });
    }
    
    // Test AI service connection
    const isConnected = await aiService.testConnection();
    if (!isConnected) {
      return res.status(503).json({
        success: false,
        error: 'AI service is not available. Please ensure Ollama is running with Qwen 4B model.'
      });
    }
    
    // Get student data with latest assessment from both 42-item and 84-item tables
    let studentAssessment = null;
    let assessmentType = null;
    
    // First try to get from 42-item assessments
    const { data: assessment42, error: error42 } = await supabase
      .from('assessments_42items')
      .select(`
        *,
        student:students(*)
      `)
      .eq('student_id', studentId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();
    
    // Then try to get from 84-item assessments
    const { data: assessment84, error: error84 } = await supabase
      .from('assessments_84items')
      .select(`
        *,
        student:students(*)
      `)
      .eq('student_id', studentId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();
    
    // Determine which assessment is more recent
    if (assessment42 && assessment84) {
      const date42 = new Date(assessment42.created_at);
      const date84 = new Date(assessment84.created_at);
      if (date42 > date84) {
        studentAssessment = assessment42;
        assessmentType = 'ryff_42';
      } else {
        studentAssessment = assessment84;
        assessmentType = 'ryff_84';
      }
    } else if (assessment42) {
      studentAssessment = assessment42;
      assessmentType = 'ryff_42';
    } else if (assessment84) {
      studentAssessment = assessment84;
      assessmentType = 'ryff_84';
    }
    
    if (!studentAssessment) {
      console.error('Error fetching student assessment - no assessments found for student:', studentId);
      return res.status(404).json({
        success: false,
        error: 'No completed assessment found for this student'
      });
    }
    
    // Prepare student data for AI generation
    const studentData = {
      name: studentAssessment.student.name,
      subscales: studentAssessment.scores || {},
      overallScore: studentAssessment.overall_score,
      atRiskDimensions: studentAssessment.at_risk_dimensions || [],
      riskLevel: studentAssessment.risk_level,
      assessmentType: assessmentType
    };
    
    // Generate structured AI intervention to ensure completeness
    const structuredIntervention = await aiService.generateStructuredIntervention(
      studentAssessment, 
      studentAssessment.risk_level
    );

    // Get counselor name
    const { data: counselor, error: counselorError } = await supabase
      .from('counselors')
      .select('name')
      .eq('id', counselorId)
      .single();

    if (counselorError) {
      console.error('Error fetching counselor:', counselorError);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch counselor information'
      });
    }

    // Save structured intervention to database with all sections
    const { data: savedIntervention, error: insertError } = await supabase
      .from('counselor_interventions')
      .insert({
        student_id: studentId,
        assessment_id: assessmentId || studentAssessment.id,
        assessment_type: assessmentType, // Add assessment type to track which assessment this intervention belongs to
        risk_level: studentAssessment.risk_level,
        intervention_title: structuredIntervention.title,
        intervention_text: structuredIntervention.interventionText,
        overall_strategy: structuredIntervention.overallStrategy,
        dimension_interventions: structuredIntervention.dimensionInterventions,
        action_plan: structuredIntervention.actionPlan,
        intervention_type: 'ai_structured',
        counselor_message: 'This intervention was manually generated by your counselor using our AI system.',
        counselor_id: counselorId,
        is_read: false
      })
      .select()
      .single();
    
    if (insertError) {
      console.error('Error saving AI intervention:', insertError);
      return res.status(500).json({
        success: false,
        error: 'Failed to save AI intervention'
      });
    }
    
    console.log(`AI intervention generated and saved with ID: ${savedIntervention.id}`);
    
    res.json({
      success: true,
      data: {
        intervention: savedIntervention,
        generatedContent: {
          title: intervention.title,
          text: intervention.text
        }
      },
      message: 'AI intervention generated and sent successfully'
    });
    
  } catch (error) {
    console.error('Error in generate intervention route:', error);
    
    // Check if this is an AI generation failure
    if (error.message && error.message.includes('Failed to generate AI intervention after')) {
      return res.status(503).json({
        success: false,
        error: 'AI service temporarily unavailable. Please try again in a few moments.',
        details: 'The AI system failed to generate a quality intervention after multiple attempts. This may be due to high server load or temporary service issues.',
        retryable: true
      });
    }
    
    res.status(500).json({
      success: false,
      error: 'Internal server error while generating intervention',
      retryable: false
    });
  }
});

// POST /api/ai-interventions/bulk-generate - Generate AI interventions for multiple students
router.post('/bulk-generate', verifyCounselorSession, async (req, res) => {
  try {
    const counselorId = req.user.id;
    const { studentIds } = req.body;
    
    console.log(`Bulk generating AI interventions for ${studentIds?.length || 0} students`);
    
    // Validate input
    if (!studentIds || !Array.isArray(studentIds) || studentIds.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Invalid studentIds array'
      });
    }
    
    // Test AI service connection
    const isConnected = await aiService.testConnection();
    if (!isConnected) {
      return res.status(503).json({
        success: false,
        error: 'AI service is not available. Please ensure Ollama is running with Qwen 4B model.'
      });
    }
    
    // Get counselor name
    const { data: counselor, error: counselorError } = await supabase
      .from('counselors')
      .select('name')
      .eq('id', counselorId)
      .single();
    
    if (counselorError) {
      console.error('Error fetching counselor:', counselorError);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch counselor information'
      });
    }
    
    const results = [];
    const errors = [];
    
    // Process each student
    for (const studentId of studentIds) {
      try {
        // Get student data with latest assessment from both 42-item and 84-item tables
        let studentAssessment = null;
        let assessmentType = null;
        
        // First try to get from 42-item assessments
        const { data: assessment42, error: error42 } = await supabase
          .from('assessments_42items')
          .select(`
            *,
            student:students(*)
          `)
          .eq('student_id', studentId)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();
        
        // Then try to get from 84-item assessments
        const { data: assessment84, error: error84 } = await supabase
          .from('assessments_84items')
          .select(`
            *,
            student:students(*)
          `)
          .eq('student_id', studentId)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();
        
        // Determine which assessment is more recent
        if (assessment42 && assessment84) {
          const date42 = new Date(assessment42.created_at);
          const date84 = new Date(assessment84.created_at);
          if (date42 > date84) {
            studentAssessment = assessment42;
            assessmentType = 'ryff_42';
          } else {
            studentAssessment = assessment84;
            assessmentType = 'ryff_84';
          }
        } else if (assessment42) {
          studentAssessment = assessment42;
          assessmentType = 'ryff_42';
        } else if (assessment84) {
          studentAssessment = assessment84;
          assessmentType = 'ryff_84';
        }
        
        if (!studentAssessment) {
          errors.push({ studentId, error: 'No completed assessment found' });
          continue;
        }
        
        // Prepare student data for AI generation
        const studentData = {
          name: studentAssessment.student.name,
          subscales: studentAssessment.scores || {},
          overallScore: studentAssessment.overall_score,
          atRiskDimensions: studentAssessment.at_risk_dimensions || [],
          riskLevel: studentAssessment.risk_level,
          assessmentType: assessmentType
        };
        
        // Generate structured AI intervention
        const structuredIntervention = await aiService.generateStructuredIntervention(
          studentData, 
          studentAssessment.risk_level
        );
        
        // Save intervention to database with structured data
        const { data: savedIntervention, error: insertError } = await supabase
          .from('counselor_interventions')
          .insert({
            student_id: studentId,
            assessment_id: studentAssessment.id,
            risk_level: studentAssessment.risk_level,
            intervention_title: structuredIntervention.title,
            intervention_text: structuredIntervention.interventionText,
            overall_strategy: structuredIntervention.overallStrategy,
            dimension_interventions: structuredIntervention.dimensionInterventions,
            action_plan: structuredIntervention.actionPlan,
            counselor_id: counselorId,
            intervention_type: 'ai_structured',
            status: 'generated',
            is_read: false
          })
          .select()
          .single();
        
        if (insertError) {
          errors.push({ studentId, error: 'Failed to save intervention' });
          continue;
        }
        
        results.push(savedIntervention);
        
        // Add small delay to avoid overwhelming the AI service
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        console.error(`Error processing student ${studentId}:`, error);
        errors.push({ studentId, error: error.message });
      }
    }
    
    console.log(`Bulk generation completed: ${results.length} successful, ${errors.length} errors`);
    
    res.json({
      success: true,
      data: {
        successful: results,
        errors: errors,
        summary: {
          total: studentIds.length,
          successful: results.length,
          failed: errors.length
        }
      },
      message: `Successfully generated ${results.length} AI interventions${errors.length > 0 ? ` with ${errors.length} errors` : ''}`
    });
    
  } catch (error) {
    console.error('Error in bulk generate intervention route:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error while bulk generating interventions'
    });
  }
});

// POST /api/ai-interventions/generate-structured - Generate structured intervention for a student
router.post('/generate-structured', verifyCounselorSession, async (req, res) => {
  try {
    const counselorId = req.user.id;
    const { studentId } = req.body;
    
    console.log('Generating structured AI intervention for student:', studentId);
    
    // Validate required fields
    if (!studentId) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: studentId'
      });
    }
    
    // Test AI service connection
    const connectionResult = await aiService.testConnection();
    if (!connectionResult.success) {
      return res.status(503).json({
        success: false,
        error: 'AI service is not available',
        details: connectionResult.error
      });
    }
    
    // Get student data with latest assessment from both 42-item and 84-item tables
    let studentAssessment = null;
    let assessmentType = null;
    
    // First try to get from 42-item assessments
    const { data: assessment42, error: error42 } = await supabase
      .from('assessments_42items')
      .select(`
        *,
        student:students(*)
      `)
      .eq('student_id', studentId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();
    
    // Then try to get from 84-item assessments
    const { data: assessment84, error: error84 } = await supabase
      .from('assessments_84items')
      .select(`
        *,
        student:students(*)
      `)
      .eq('student_id', studentId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();
    
    // Determine which assessment is more recent
    if (assessment42 && assessment84) {
      const date42 = new Date(assessment42.created_at);
      const date84 = new Date(assessment84.created_at);
      if (date42 > date84) {
        studentAssessment = assessment42;
        assessmentType = 'ryff_42';
      } else {
        studentAssessment = assessment84;
        assessmentType = 'ryff_84';
      }
    } else if (assessment42) {
      studentAssessment = assessment42;
      assessmentType = 'ryff_42';
    } else if (assessment84) {
      studentAssessment = assessment84;
      assessmentType = 'ryff_84';
    }
    
    if (!studentAssessment) {
      console.error('Error fetching student assessment - no assessments found for student:', studentId);
      return res.status(404).json({
        success: false,
        error: 'No completed assessment found for this student'
      });
    }
    
    // Generate structured intervention using AI
    const structuredIntervention = await aiService.generateStructuredIntervention(
      studentAssessment,
      studentAssessment.risk_level
    );
    
    // Save to database
    const { data: savedIntervention, error: saveError } = await supabase
      .from('counselor_interventions')
      .insert({
        counselor_id: counselorId,
        student_id: studentId,
        assessment_id: studentAssessment.id,
        intervention_title: structuredIntervention.title,
        intervention_text: structuredIntervention.interventionText,
        overall_strategy: structuredIntervention.overallStrategy,
        dimension_interventions: structuredIntervention.dimensionInterventions,
        action_plan: structuredIntervention.actionPlan,
        intervention_type: 'ai_structured',
        status: 'generated'
      })
      .select()
      .single();
    
    if (saveError) {
      console.error('Error saving structured intervention:', saveError);
      return res.status(500).json({
        success: false,
        error: 'Failed to save intervention to database'
      });
    }
    
    res.json({
      success: true,
      data: {
        intervention: savedIntervention,
        structured: structuredIntervention
      }
    });
    
  } catch (error) {
    console.error('Error generating structured intervention:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error while generating structured intervention'
    });
  }
});

// POST /api/ai-interventions/auto-generate-all - Automatically generate interventions for all students
router.post('/auto-generate-all', verifyCounselorSession, async (req, res) => {
  try {
    const counselorId = req.user.id;
    
    console.log('Auto-generating interventions for all students');
    
    // Test AI service connection
    const connectionResult = await aiService.testConnection();
    if (!connectionResult.success) {
      return res.status(503).json({
        success: false,
        error: 'AI service is not available',
        details: connectionResult.error
      });
    }
    
    // Get all students with completed assessments who don't have recent interventions
    // Query from both assessment tables
    const { data: assessments42, error: error42 } = await supabase
      .from('assessments_42items')
      .select(`
        student_id,
        id,
        risk_level,
        overall_score,
        scores,
        at_risk_dimensions,
        created_at,
        student:students(*)
      `)
      .not('risk_level', 'is', null)
      .order('created_at', { ascending: false });
    
    const { data: assessments84, error: error84 } = await supabase
      .from('assessments_84items')
      .select(`
        student_id,
        id,
        risk_level,
        overall_score,
        scores,
        at_risk_dimensions,
        created_at,
        student:students(*)
      `)
      .not('risk_level', 'is', null)
      .order('created_at', { ascending: false });
    
    if (error42 || error84) {
      console.error('Error fetching students:', error42 || error84);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch student assessments'
      });
    }
    
    // Combine assessments from both tables with assessment type
    const allAssessments = [
      ...(assessments42?.map(a => ({ ...a, assessmentType: 'ryff_42' })) || []),
      ...(assessments84?.map(a => ({ ...a, assessmentType: 'ryff_84' })) || [])
    ];
    
    // Filter to get latest assessment per student
    const latestAssessments = new Map();
    allAssessments.forEach(assessment => {
      const existing = latestAssessments.get(assessment.student_id);
      if (!existing || new Date(assessment.created_at) > new Date(existing.created_at)) {
        latestAssessments.set(assessment.student_id, assessment);
      }
    });
    
    const results = [];
    const errors = [];
    
    // Process each student
    for (const [studentId, assessment] of latestAssessments) {
      try {
        // Check if student already has a recent intervention (within last 2 minutes)
        const { data: existingIntervention } = await supabase
          .from('counselor_interventions')
          .select('id, created_at')
          .eq('student_id', studentId)
          .eq('intervention_type', 'ai_structured')
          .gte('created_at', new Date(Date.now() - 2 * 60 * 1000).toISOString())
          .limit(1)
          .single();
        
        if (existingIntervention) {
          console.log(`Skipping student ${studentId} - recent intervention exists`);
          continue;
        }
        
        // Prepare student data for AI generation
        const studentData = {
          student: assessment.student,
          subscales: assessment.scores || {},
          overall_score: assessment.overall_score,
          at_risk_dimensions: assessment.at_risk_dimensions || [],
          risk_level: assessment.risk_level,
          assessmentType: assessment.assessmentType
        };
        
        // Generate structured intervention
        const structuredIntervention = await aiService.generateStructuredIntervention(
          studentData,
          assessment.risk_level
        );
        
        // Save to database
        const { data: savedIntervention, error: saveError } = await supabase
          .from('counselor_interventions')
          .insert({
            counselor_id: counselorId,
            student_id: studentId,
            assessment_id: assessment.id,
            intervention_title: structuredIntervention.title,
            intervention_text: structuredIntervention.interventionText,
            overall_strategy: structuredIntervention.overallStrategy,
            dimension_interventions: structuredIntervention.dimensionInterventions,
            action_plan: structuredIntervention.actionPlan,
            intervention_type: 'ai_structured',
            status: 'pending'
          })
          .select()
          .single();
        
        if (saveError) {
          console.error(`Error saving intervention for student ${studentId}:`, saveError);
          errors.push({
            studentId,
            error: 'Failed to save intervention'
          });
        } else {
          results.push({
            studentId,
            interventionId: savedIntervention.id,
            studentName: assessment.student?.name || 'Unknown'
          });
        }
        
      } catch (error) {
        console.error(`Error processing student ${studentId}:`, error);
        errors.push({
          studentId,
          error: error.message
        });
      }
    }
    
    res.json({
      success: true,
      data: {
        generated: results,
        errors: errors,
        summary: {
          total: latestAssessments.size,
          successful: results.length,
          failed: errors.length
        }
      }
    });
    
  } catch (error) {
    console.error('Error in auto-generate-all:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error during auto-generation'
    });
  }
});

// GET /api/ai-interventions/test-connection - Test AI service connection
router.get('/test-connection', verifyCounselorSession, async (req, res) => {
  try {
    const connectionResult = await aiService.testConnection();
    
    if (connectionResult.success) {
      res.json({
        success: true,
        data: {
          connected: true,
          model: connectionResult.model,
          service: 'Ollama with Qwen 4B',
          endpoint: 'http://localhost:11434'
        },
        message: 'AI service is available and ready'
      });
    } else {
      res.status(503).json({
        success: false,
        data: {
          connected: false,
          service: 'Ollama with Qwen 4B',
          endpoint: 'http://localhost:11434'
        },
        message: connectionResult.error || 'AI service is not available'
      });
    }
    
  } catch (error) {
    console.error('Error testing AI connection:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to test AI service connection'
    });
  }
});

// GET /api/ai-interventions/status/:studentId - Check intervention status for a student
router.get('/status/:studentId', verifyCounselorSession, async (req, res) => {
  try {
    const { studentId } = req.params;
    const counselorId = req.user.id;

    // Check if there's an existing intervention for this student
    const { data: existingIntervention, error: fetchError } = await supabase
      .from('counselor_interventions')
      .select('id, created_at, updated_at')
      .eq('student_id', studentId)
      .eq('counselor_id', counselorId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (fetchError && fetchError.code !== 'PGRST116') {
      console.error('Error checking intervention status:', fetchError);
      return res.status(500).json({
        success: false,
        error: 'Failed to check intervention status'
      });
    }

    const hasIntervention = !!existingIntervention;
    const isGenerating = false; // We'll track this in a more sophisticated way if needed

    res.json({
      success: true,
      data: {
        hasIntervention,
        isGenerating,
        lastUpdated: existingIntervention?.updated_at || null
      }
    });

  } catch (error) {
    console.error('Error checking intervention status:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error while checking intervention status'
    });
  }
});

// Development endpoint to generate interventions without authentication
// Remove this in production!
router.post('/dev-generate-all', async (req, res) => {
  try {
    console.log('ðŸš€ DEV: Auto-generating interventions for all students');
    
    // Test AI service connection
    const connectionResult = await aiService.testConnection();
    if (!connectionResult.success) {
      return res.status(503).json({
        success: false,
        error: 'AI service is not available',
        details: connectionResult.error
      });
    }
    
    // Get all students with completed assessments who don't have recent interventions
    // Query from both assessment tables
    const { data: assessments42, error: error42 } = await supabase
      .from('assessments_42items')
      .select(`
        student_id,
        id,
        risk_level,
        overall_score,
        scores,
        at_risk_dimensions,
        created_at,
        student:students(*)
      `)
      .not('risk_level', 'is', null)
      .order('created_at', { ascending: false });
    
    const { data: assessments84, error: error84 } = await supabase
      .from('assessments_84items')
      .select(`
        student_id,
        id,
        risk_level,
        overall_score,
        scores,
        at_risk_dimensions,
        created_at,
        student:students(*)
      `)
      .not('risk_level', 'is', null)
      .order('created_at', { ascending: false });
    
    if (error42 || error84) {
      console.error('Error fetching students:', error42 || error84);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch student assessments'
      });
    }
    
    // Combine assessments from both tables with assessment type
    const allAssessments = [
      ...(assessments42?.map(a => ({ ...a, assessmentType: 'ryff_42' })) || []),
      ...(assessments84?.map(a => ({ ...a, assessmentType: 'ryff_84' })) || [])
    ];
    
    // Filter to get latest assessment per student
    const latestAssessments = new Map();
    allAssessments.forEach(assessment => {
      const existing = latestAssessments.get(assessment.student_id);
      if (!existing || new Date(assessment.created_at) > new Date(existing.created_at)) {
        latestAssessments.set(assessment.student_id, assessment);
      }
    });
    
    const results = [];
    const errors = [];
    
    // Process each student
    for (const [studentId, assessment] of latestAssessments) {
      try {
        // Check if student already has any intervention
        const { data: existingIntervention } = await supabase
          .from('counselor_interventions')
          .select('id, created_at')
          .eq('student_id', studentId)
          .limit(1)
          .single();
        
        if (existingIntervention) {
          console.log(`Skipping student ${studentId} - intervention already exists`);
          continue;
        }
        
        // Prepare student data for AI generation
        const studentData = {
          student: assessment.student,
          subscales: assessment.scores || {},
          overall_score: assessment.overall_score,
          at_risk_dimensions: assessment.at_risk_dimensions || [],
          risk_level: assessment.risk_level,
          assessmentType: assessment.assessmentType
        };
        
        // Generate structured intervention
        const structuredIntervention = await aiService.generateStructuredIntervention(
          studentData,
          assessment.risk_level
        );
        
        // Save to database (using a dummy counselor_id for development)
        const { data: savedIntervention, error: saveError } = await supabase
          .from('counselor_interventions')
          .insert({
            counselor_id: '00000000-0000-0000-0000-000000000000', // Dummy counselor ID for dev
            student_id: studentId,
            assessment_id: assessment.id,
            intervention_title: structuredIntervention.title,
            intervention_text: structuredIntervention.interventionText,
            overall_strategy: structuredIntervention.overallStrategy,
            dimension_interventions: structuredIntervention.dimensionInterventions,
            action_plan: structuredIntervention.actionPlan,
            intervention_type: 'ai_structured',
            status: 'generated'
          })
          .select()
          .single();
        
        if (saveError) {
          console.error(`Error saving intervention for student ${studentId}:`, saveError);
          errors.push({
            studentId,
            error: 'Failed to save intervention'
          });
        } else {
          results.push({
            studentId,
            interventionId: savedIntervention.id,
            studentName: assessment.student?.name || 'Unknown'
          });
        }
        
      } catch (error) {
        console.error(`Error processing student ${studentId}:`, error);
        errors.push({
          studentId,
          error: error.message
        });
      }
    }
    
    res.json({
      success: true,
      data: {
        generated: results,
        errors: errors,
        summary: {
          total: latestAssessments.size,
          successful: results.length,
          failed: errors.length
        }
      }
    });
    
  } catch (error) {
    console.error('Error in dev-generate-all:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error during auto-generation'
    });
  }
});

module.exports = router;